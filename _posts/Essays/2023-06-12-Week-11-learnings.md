---
category: Essays
title: Week 11 
date: 2023-06-12
---

This week has been an enlightening roller-coaster ride for me. I finally unraveled the enigmatic tapestry surrounding the ``static`` keyword. I now comprehend the essence of class methods and variables, and how they stand in contrast to instance methods and variables. Plus, I understand why non-static members can’t just waltz into a static context. I must confess, in the past, my approach to dealing with the dreaded “non-static reference in static context” errors was akin to a child scribbling with crayons - I would just scrawl “static” here and there until my code miraculously complied. However, armed with my newfound understanding, I vow to wield the “static” keyword with the precision of a surgeon, ensuring that I fully grasp its role in any code I work with.

Additionally, I had the chance to explore the intricacies of class inheritance in the Hyperskill's Java lessons. I delved into the mechanics of constructors, particularly within subclasses, and the strategic utility of interfaces in the labyrinthine world of inheritance. While I was not entirely unfamiliar with these notions, my prior understanding was more rooted in generic object-oriented principles. This time, however, it felt like I was deciphering the language-specific scriptures, and I emerged well-equipped to navigate the architectural wonders of sophisticated software designs.

As someone who loves to share knowledge, preparing a presentation is like an exciting treasure hunt. While I was no stranger to these architectures, they housed certain enigmatic elements. I chuckled at the realization that, despite employing REST architecture for over a year, the secrets behind its very name eluded me. “Representational State Transfer” was a jumble of words until I dissected the significance of “state” and its “representational” nature. With these mysteries solved, REST’s design principles now make more sense and are easier to remember. I also discovered an invaluable piece of information: filtering, sorting, and paginating server responses is the best practice, especially with bulky data. While I personally regard filtering and sorting as somewhat excessive, paginating server responses seems like sheer genius.

During my intellectual expedition, I stumbled upon a magnificent artifact – the ResponseEntityExceptionHandler class. Nestled within the Spring Boot framework, this gem is useful for handling exceptions alongside their corresponding HTTP error codes in RESTful APIs. Gone are the days when I would clumsily juggle exception handling within my RestController and Service classes, or, even worse, forgo adding HTTP status codes altogether. Now, with ResponseEntityExceptionHandler by my side, I can grace my APIs with HTTP error status codes, doing it the right way.

 Aditionally, my voyage brought me face-to-face with the Controller-Service-Repository pattern. It was a eureka moment to learn that this is an adroit variation of the classic Model-View-Controller pattern, tailored for APIs. I learned a plethora of best practices for this design pattern, such as maintaining exception handling within the Controller layer,keeping the Entity-DTO parseing within the Service layer, and logging useful server information in the Service layer.

To top it all off, I successfully penned my very first unit tests and integration tests from scratch for the charming “cats” API I showcased. My earlier tryst with testing in Java and Spring either felt like stumbling in the dark or like hitting my head against a brick. Succeeding in writing tests from scratch for a simple API was an empowering, triumphant experience. The scales have fallen from my eyes, and my former aversion to writing tests has transformed into a newfound respect.

With this enriching week behind me, I stand tall, my horizons broadened, and my toolkit brimming with knowledge. I can hardly wait to set sail on my next learning adventure!
