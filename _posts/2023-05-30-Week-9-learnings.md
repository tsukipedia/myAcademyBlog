---
title: Week 9 Essay 
date: 2023-05-30
---

This week, I acquired a wealth of knowledge about Redux, including how to make API calls, the usefulness and limitations of async thunks, utilizing API slices, normal slices, and implementing both API slices and normal slices within the same project. I had previously read about how Redux manages states without the need to pass them as props, and upon developing a project with Redux, I can confidently say it's an amazing tool. However, getting accustomed to a new technology can be challenging, particularly when the documentation is inadequate, as is the case with Redux. The documentation is contradictory, code examples contain errors, and tutorials are incomplete. Nevertheless, once you configure the store with all the necessary components, the programming experience becomes incredibly smooth.

While I do have an inclination towards aesthetics and beauty, I often find it difficult to appreciate visually appealing dashboards, as  they often come with complex code that lacks practicality. A front-end technology I learned in order to cope with this was Material UI (MUI). I had previous experience using MUI in a project with a custom UI library that closely resembled MUI and whenever we needed a component outside of that private library's scope, we would turn to MUI. Some of the MUI components and actions I became acquainted with in this project include pagination, enhanced table, paper, box, grid, dialog, button, table column sorting, and date inputs and formatting. I believe MUI is a good library for creating complex components with practical code, but its documentation for simple components is incomplete. Surprisingly, I spent more time figuring out how to add simple MUI components to my project than the complex ones.

Despite considering myself a full-stack developer, I have predominantly worked on the back end. As a result, there was less to learn in terms of Java and Spring, but I did gain new insights into these technologies. For instance, I explored the usefulness of the Optional class for managing nullable values and handling exceptions that it can throw, which contributes to building a more robust product. Additionally, I deepened my understanding of Date manipulation, going beyond simple parsing and comparison. I had the opportunity to serialize Dates, sort elements based on Dates, and calculate average time differences between Date elements within a list. In previous projects, string manipulation was predominantly used for managing dates, I'm uncertain if that was a project-specific choice or a standard practice, personally, I believe programming languages offer powerful date functions that we should leverage. Moreover, I learned how to set up a repository layer in Spring without a database connection, although its practicality in the future remains uncertain.

During this week, I also encountered common web app functionalities that require a collaborative design of API and UI. Initially, I assumed that pagination could be solely handled on the front end, but I learned that it is more effective to manage it from the back end. But then, sorting functionalities can be affected if React components are responsible for sorting. I became aware of this when it was raised in the Slack channel. Reflecting on this issue, I concluded that the solution suggested by Rafael might not have been the best, but the requirement itself was ambiguous. The requirement stated the need to sort items based on their due date and priority, with a sorting icon provided in the Due Date and Priority columns header. Sorting all elements when clicking on a column header sort icon might cause users to lose the information they were initially viewing, leading to confusion. However, it's logical to want to sort all elements in a To-Do list by due date and priority. To resolve this, I implemented both sorting behaviors—sorting all elements and sorting the current page's elements—in different components to reduce confusion without sacrificing valuable functionality.